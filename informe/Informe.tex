\documentclass[10 pt, A4paper]{article}
\title{Informe para el Trabajo Práctico Especial - Programación III}
\author{Fonzo Baniles, Luca \& Cagliolo, Camilo}
\date{02/07/2023}
\usepackage[utf8]{inputenc}
\usepackage[skip=5pt, indent = 10pt]{parskip}
\usepackage[hoffset=0pt,voffset=0pt,]{geometry}
\usepackage{csquotes}
\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{hyperref}
\usepackage[spanish]{babel}

\usepackage{multirow}
\setlength{\arrayrulewidth}{0.5mm}
\renewcommand{\arraystretch}{2}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	language=Java,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}

\begin{document}
	\maketitle
	\section*{Consigna}
	\begin{displayquote}
		\textit{Las autoridades de una ciudad deciden construir una red de subterráneos para resolver los constantes problemas de tráfico. La ciudad ya cuenta con N estaciones construidas, pero todavía no tienen ningún túnel que conecte ningún par de estaciones entre sí. La red de subterráneos que se construya debe incluir a todas las estaciones (es decir, que de cualquier estación H pueda llegar a cualquier otra estación J, ya sea de manera directa o atravesando otras estaciones). Sin embargo, debido al acotado presupuesto, las autoridades desean construir la menor cantidad de metros de túnel posibles . Para esto han calculado cuantos metros de túnel serían necesarios para conectar de manera directa cada par de estaciones existentes.}
	\end{displayquote}
	\subsection*{Objetivo}
	El objetivo es resolver el problema planteado mediante dos técnicas algorítmicas distintas: Backtracking y Greedy. Luego se deberán comparar los resultados teniendo en cuenta distintas métricas que permitan visualizar, mínimamente, la calidad de la solución y el costo de obtener dicha solución, con ambas técnicas.
	\section*{Solución}
	\subsection*{Algoritmo greedy}
	
	\textbf{Estrategia.} La estrategia empleada para la implementación del algoritmo greedy consistió en, para cada vértice, realizar la selección del arco más corto siempre y cuando dicho arco no tuviera como destino un vértice con un arco ya asignado.
	
	\textbf{Complejidad temporal.} Como consecuencia del funcionamiento del algoritmo, la estrategia greedy hace un repaso por cada vértice y a su vez, por cada vértice, el proceso de selección repasa todos los otros vértices que aún no han sido visitados, generando así una complejidad temporal de $O(n^2)$ siendo $n$ la cantidad de vértices en el grafo.
	
	\subsection*{Algoritmo de backtracking}

	\textbf{Estrategia.} La estrategia consistió en construir una solución seleccionando un túnel por cada estación de forma sucesiva hasta quedarse sin estaciones que conectar. Dentro de la lista de posibles túneles a construir para cada estación, están los que llevan a cualquier estación sin túnel o bien el túnel ya construido que vuelve inmediatamente hacia la estación anterior (esto evita los ciclos en el grafo, que implicarían la construcción de túneles de más). 
	
	El carácter recursivo de la implementación con la estrategia de backtracking asegura la construcción de todas las combinaciones posibles de $n-1$ túneles para $n$ estaciones, visitando una por vez. Como el problema se trata de minimizar la distancia total, la condición fundamental de poda es asegurar que la construcción actual sea más corta que la última solución encontrada, pues de lo contrario no tiene sentido seguir construyendo: las distancias son cantidades siempre positivas. 
	
	[PONER UN ÁRBOL DE BÚSQUEDA ACÁ]
	
	\textbf{Complejidad temporal.} 
	
	\section*{Análisis}
	El cuadro \ref{table} muestra una tabla comparativa con las diferencias entre los algoritmos con estrategias \textit{greedy} y \textit{backtracking}, analizando el tiempo de ejecución y la cantidad de ciclos, además de la complejidad computacional teórica.
	
	\begin{table}[h!]
		\centering
		\begin{tabular}{|p{4cm} | p{3cm} | p{3cm} | p{3cm}|}
			\hline
			Algoritmo & Dataset 1 & Dataset 2 & Dataset 3 \\
			\hline
			\multirow{2}{1em}{Greedy $O(n^2)$} & Tiempo: $0.325\,ms$ & Tiempo: $0.325\,ms$& Tiempo: $0.325\,ms$ \\ & Ciclos: $126$ & Ciclos: $126$ & Ciclos: $126$ \\
			\hline
			\multirow{2}{1em}{Backtracking $O(n!)$} & Tiempo: $0.325\,ms$& Tiempo: $0.325\,ms$& Tiempo: $0.325\,ms$\\ & Ciclos: $126$ & Ciclos: $126$ & Ciclos: $126$ \\
			\hline
		\end{tabular}
		\caption{Comparación de \textit{benchmarks} entre las dos estrategias}
		\label{table}
	\end{table}
	
	\section*{Conclusiones}
	A partir de lo analizado y lo trabajado en clase, es posible llegar a las siguientes conclusiones:
	\begin{itemize}
		\item[$\circ$] Los algoritmos de tipo greedy pueden otorgar soluciones que están muy cerca de ser la óptima, consumiendo muchos menos recursos que su contraparte de backtracking.
		\item[$\circ$] Los algoritmos de backtracking aseguran la solución más óptima, por lo que si el costo computacional es pagable, podría ser preferible.
		\item[$\circ$] Una combinación de ambas metodologías podría permitir podar gran parte del árbol de búsqueda del algoritmo de backtracking, utilizando como filtro los resultados del algoritmo greedy.
	\end{itemize}
	
	
	
%	\begin{lstlisting}
%		// Hello.java
%		import javax.swing.JApplet;
%		import java.awt.Graphics;
%		
%		public class Hello extends JApplet {
%			public void paintComponent(Graphics g) {
%				g.drawString("Hello, world!", 65, 95);
%			}    
%		}
%	\end{lstlisting}
	
	
\end{document}